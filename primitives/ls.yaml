---
name: "ls"
description: "Load/Store primitives"
...
---
primitive_name: "load"
brief_description: "Loads data from aligned memory into a vector register."
parameters:
   - ctype: "const typename Vec::base_type *"
     attributes: "__restrict__"
     name: "memory"
     description: "Aligned memory which should be transferred into a vector register."
returns:
   ctype: "typename Vec::register_type"
   description: "Vector containing the loaded data."
testing:
   -  requires: ["storeu"]
      includes: ["<cstddef>", "<cstring>"]
      implementation: |
         using T = typename Vec::base_type;
         std::size_t element_count = 1024;
         testing::test_memory_helper_t<Vec> test_helper{element_count, Vec::vector_element_count(), true};
         bool allOk = true;
         auto reference_data_ptr = test_helper.data_ref();
         auto reference_result_ptr = test_helper.result_ref();
         auto test_data_ptr = test_helper.data_target();
         auto test_result_ptr = test_helper.result_target();
         for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
            for(size_t j = i; j < i + Vec::vector_element_count(); ++j) {
               reference_result_ptr[j-i] = reference_data_ptr[j];
            }
            auto loaded = load<Vec>(&test_data_ptr[i]);
            storeu<Vec>(test_result_ptr, loaded);
            test_helper.synchronize();
            allOk &= test_helper.validate();
         }
         return allOk;
definitions:
#INTEL - AVX512
   - target_extension: "avx512"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ["avx512f"]
     implementation: "return _mm512_load_si512(reinterpret_cast<void const *>(memory));"
   - target_extension: "avx512"
     ctype: ["float", "double"]
     lscpu_flags: ["avx512f"]
     implementation: "return _mm512_load_{{ intrin_tp_full[ctype] }}(reinterpret_cast<void const *>(memory));"
#INTEL - AVX2
   - target_extension: "avx2"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ["avx"]
     implementation: "return _mm256_load_si256(reinterpret_cast<__m256i const *>(memory));"
   - target_extension: "avx2"
     ctype: ["float", "double"]
     lscpu_flags: ["avx"]
     implementation: "return _mm256_load_{{ intrin_tp_full[ctype] }}(memory);"
#INTEL - SSE
   - target_extension: "sse"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ["sse2"]
     implementation: "return _mm_load_si128(reinterpret_cast<__m128i const *>(memory));"
   - target_extension: "sse"
     ctype: ["float"]
     lscpu_flags: ["sse"]
     implementation: "return _mm_load_ps(memory);"
   - target_extension: "sse"
     ctype: ["double"]
     lscpu_flags: ["sse2"]
     implementation: "return _mm_load_pd(memory);"
#ARM - NEON
   - target_extension: "neon"
     ctype: "int64_t"
     lscpu_flags: ["neon"]
     implementation: "return vld1q_{{ intrin_tp_full[ctype] }}(memory);"
#SCALAR
   - target_extension: "scalar"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
     lscpu_flags: []
     implementation: "return *memory;"
#FPGA
   - target_extension: "fpga"
     ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "float", "uint64_t", "int64_t", "double"]
     lscpu_flags: ["fpga"]
     vector_length_agnostic: True
     implementation: |
        using T = typename Vec::register_type;
        T reg; //initialize the result
        #pragma unroll
        for (size_t idx = 0; idx < Vec::vector_element_count(); idx++) {
          reg[idx] = memory[idx];
        }
        return reg;
...
---
primitive_name: "loadu"
brief_description: "Loads data from (un)aligned memory into a vector register."
parameters:
   - ctype: "const typename Vec::base_type *"
     attributes: "__restrict__"
     name: "memory"
     description: "(Un)aligned memory which should be transferred into a vector register."
returns:
   ctype: "typename Vec::register_type"
   description: "Vector containing the loaded data."
testing:
   -  requires: ["storeu"]
      includes: ["<cstddef>", "<cstring>"]
      implementation: |
         using T = typename Vec::base_type;
         std::size_t element_count = 1024;
         testing::test_memory_helper_t<Vec> test_helper{element_count, Vec::vector_element_count(), false};
         bool allOk = true;
         auto reference_data_ptr = test_helper.data_ref();
         auto reference_result_ptr = test_helper.result_ref();
         auto test_data_ptr = test_helper.data_target();
         auto test_result_ptr = test_helper.result_target();
         for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
            for(size_t j = i; j < i + Vec::vector_element_count(); ++j) {
               reference_result_ptr[j-i] = reference_data_ptr[j];
            }
            auto loaded = loadu<Vec>(&test_data_ptr[i]);
            storeu<Vec>(test_result_ptr, loaded);
            test_helper.synchronize();
            allOk &= test_helper.validate();
         }
         return allOk;
definitions:
#INTEL - AVX512
   - target_extension: "avx512"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ["avx512f"]
     implementation: "return _mm512_loadu_si512(reinterpret_cast<void const *>(memory));"
   - target_extension: "avx512"
     ctype: ["float", "double"]
     lscpu_flags: ["avx512f"]
     implementation: "return _mm512_loadu_{{ intrin_tp_full[ctype] }}(reinterpret_cast<void const *>(memory));"
#INTEL - AVX2
   - target_extension: "avx2"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ['avx']
     implementation: "return _mm256_loadu_si256( reinterpret_cast< __m256i const * >( memory ) );"
   - target_extension: "avx2"
     ctype: ["float", "double"]
     lscpu_flags: ["avx"]
     implementation: "return _mm256_loadu_{{ intrin_tp_full[ctype] }}(memory);"
#INTEL - SSE
   - target_extension: "sse"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ["sse2"]
     implementation: "return _mm_loadu_si128(reinterpret_cast<__m128i const *>(memory));"
   - target_extension: "sse"
     ctype: ["float"]
     lscpu_flags: ["sse"]
     implementation: "return _mm_load_ps(memory);"
   - target_extension: "sse"
     ctype: ["double"]
     lscpu_flags: ["sse2"]
     implementation: "return _mm_load_pd(memory);"
#ARM - NEON
   - target_extension: "neon"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
     lscpu_flags: [ 'neon' ]
     implementation: "return vld1q_{{ intrin_tp_full[ctype] }}(memory);"
#SCALAR
   - target_extension: "scalar"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
     lscpu_flags: []
     implementation: "return *memory;"
#FPGA
   - target_extension: "fpga"
     ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "float", "uint64_t", "int64_t", "double"]
     lscpu_flags: ["fpga"]
     vector_length_agnostic: True
     implementation: |
        using T = typename Vec::register_type;
        T reg; //initialize the result
        #pragma unroll
        for (size_t idx = 0; idx < Vec::vector_element_count(); idx++) {
          reg[idx] = memory[idx];
        }
        return reg;
...
---
primitive_name: "store"
brief_description: "Stores data from a vector register to aligned memory."
parameters:
   - ctype: "typename Vec::base_type *"
     attributes: "__restrict__"
     name: "memory"
     description: "Aligned memory where the data should be stored into."
   - ctype: "const typename Vec::register_type"
     name: "data"
     description: "Vector containing the data."
testing:
   -  requires: ["set1"]
      includes: ["<cstddef>", "<cstring>"]
      implementation: |
         using T = typename Vec::base_type;
         std::size_t element_count = 1024;
         testing::test_memory_helper_t<Vec> test_helper{Vec::vector_element_count(), true};
         bool allOk = true;
         auto reference_data_ptr = test_helper.data_ref();
         auto reference_result_ptr = test_helper.result_ref();
         auto test_data_ptr = test_helper.data_target();
         auto test_result_ptr = test_helper.result_target();
         for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
            for(size_t j = i; j < i + Vec::vector_element_count(); ++j) {
               reference_result_ptr[j-i] = i;
            }
            auto loaded = set1<Vec>(i);
            store<Vec>(test_result_ptr, loaded);
            test_helper.synchronize();
            allOk &= test_helper.validate();
         }
         return allOk;
definitions:
#INTEL - AVX512
   - target_extension: "avx512"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ["avx512f"]
     implementation: "_mm512_store_si512(reinterpret_cast<void *>(memory), data);"
   - target_extension: "avx512"
     ctype: ["float", "double"]
     lscpu_flags: ["avx512f"]
     implementation: "_mm512_store_{{ intrin_tp_full[ctype] }}(reinterpret_cast<void *>(memory), data);"
#INTEL - AVX2
   - target_extension: "avx2"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ["avx"]
     implementation: "_mm256_store_si256(reinterpret_cast<__m256i *>(memory), data);"
   - target_extension: "avx2"
     ctype: ["float", "double"]
     lscpu_flags: ["avx"]
     implementation: "_mm256_store_{{ intrin_tp_full[ctype] }}(memory, data);"
#INTEL - SSE
   - target_extension: "sse"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ["sse2"]
     implementation: "_mm_store_si128(reinterpret_cast<__m128i *>(memory), data);"
   - target_extension: "sse"
     ctype: ["float"]
     lscpu_flags: ["sse"]
     implementation: "_mm_store_ps(memory, data);"
   - target_extension: "sse"
     ctype: ["double"]
     lscpu_flags: ["sse2"]
     implementation: "_mm_store_pd(memory, data);"
#ARM - NEON
   - target_extension: "neon"
     ctype: "int64_t"
     lscpu_flags: ["neon"]
     implementation: "vst1q_{{ intrin_tp_full[ctype] }}(memory, data);"
#SCALAR
   - target_extension: "scalar"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
     lscpu_flags: []
     implementation: "*memory = data;"
...
---
primitive_name: "storeu"
brief_description: "Stores data from a vector register to (un)aligned memory."
parameters:
   - ctype: "typename Vec::base_type *"
     attributes: "__restrict__"
     name: "memory"
     description: "(Un)aligned memory where the data should be stored into."
   - ctype: "const typename Vec::register_type"
     name: "data"
     description: "Vector containing the data."
testing:
   -  requires: ["set1"]
      includes: ["<cstddef>", "<cstring>"]
      implementation: |
         using T = typename Vec::base_type;
         std::size_t element_count = 1024;
         testing::test_memory_helper_t<Vec> test_helper{Vec::vector_element_count(), false};
         bool allOk = true;
         auto reference_result_ptr = test_helper.result_ref();
         auto test_result_ptr = test_helper.result_target();
         for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
            for(size_t j = i; j < i + Vec::vector_element_count(); ++j) {
               reference_result_ptr[j-i] = i;
            }
            auto loaded = set1<Vec>(i);
            storeu<Vec>(test_result_ptr, loaded);
            test_helper.synchronize();
            allOk &= test_helper.validate();
         }
         return allOk;
definitions:
#INTEL - AVX512
   - target_extension: "avx512"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ["avx512f"]
     implementation: "_mm512_storeu_si512(reinterpret_cast<void *>(memory), data);"
   - target_extension: "avx512"
     ctype: ["float", "double"]
     lscpu_flags: ["avx512f"]
     implementation: "_mm512_storeu_{{ intrin_tp_full[ctype] }}(reinterpret_cast<void *>(memory), data);"
#INTEL - AVX2
   - target_extension: "avx2"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ["avx"]
     implementation: "_mm256_storeu_si256(reinterpret_cast<__m256i *>(memory), data);"
   - target_extension: "avx2"
     ctype: ["float", "double"]
     lscpu_flags: ["avx"]
     implementation: "_mm256_storeu_{{ intrin_tp_full[ctype] }}(memory, data);"
#INTEL - SSE
   - target_extension: "sse"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ["sse2"]
     implementation: "_mm_storeu_si128(reinterpret_cast<__m128i *>(memory), data);"
   - target_extension: "sse"
     ctype: ["float"]
     lscpu_flags: ["sse"]
     implementation: "_mm_storeu_ps(memory, data);"
   - target_extension: "sse"
     ctype: ["double"]
     lscpu_flags: ["sse2"]
     implementation: "_mm_storeu_pd(memory, data);"
#ARM - NEON
   - target_extension: "neon"
     ctype: "int64_t"
     lscpu_flags: ["neon"]
     implementation: "vst1q_{{ intrin_tp_full[ctype] }}(memory, data);"
#SCALAR
   - target_extension: "scalar"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
     lscpu_flags: []
     implementation: "*memory = data;"
#FPGA
   - target_extension: "fpga"
     ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "float", "uint64_t", "int64_t", "double"]
     lscpu_flags: ["fpga"]
     vector_length_agnostic: True
     implementation: |
        using T = typename Vec::register_type;
        #pragma unroll
        for (size_t idx = 0; idx < Vec::vector_element_count(); idx++) {
          memory[idx] = data[idx];
        }
...
---
primitive_name: "set1"
brief_description: "Broadcasts a single value into all lanes of a vector register."
parameters:
   - ctype: "const typename Vec::base_type"
     name: "value"
     description: "Value which should be broadcasted."
returns:
   ctype: "typename Vec::register_type"
   description: "Vector containing the same value in all lanes."
testing:
   -
      includes: ["<cstddef>", "<algorithm>", "<limits>"]
      implementation: |
         std::size_t element_count = 1024;
         bool allOk = true;
         testing::test_memory_helper_t<Vec> test_helper{Vec::vector_element_count(), false};
         const std::size_t limit = std::min((std::size_t) 4096, (std::size_t) std::numeric_limits<typename Vec::base_type>::max());
         auto reference_result_ptr = test_helper.result_ref();
         auto test_result_ptr = test_helper.result_target();
         for(std::size_t i = 0; i < limit; ++i) {
            auto vec = set1<Vec>(i);
            for(std::size_t j = 0; j < Vec::vector_element_count(); j++) {
               reference_result_ptr[j] = i;
            }
            allOk &= test_helper.validate_simd_register(vec);
         }
         const auto maxval = std::numeric_limits<typename Vec::base_type>::max();
         auto max_vec = set1<Vec>(maxval);
         for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
            reference_result_ptr[i] = maxval;
         }
         allOk &= test_helper.validate_simd_register(max_vec);
         return allOk;
definitions:
#INTEL - AVX512
   - target_extension: "avx512"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ["avx512f"]
     implementation: "return _mm512_set1_epi{{ intrin_tp[ctype][1] }}(value);"
   - target_extension: "avx512"
     ctype: ["float", "double"]
     lscpu_flags: ["avx512f"]
     implementation: "return _mm512_set1_{{ intrin_tp_full[ctype] }}(value);"
#INTEL - AVX2
   - target_extension: "avx2"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "int8_t", "int16_t", "int32_t"]
     lscpu_flags: ["avx"]
     implementation: "return _mm256_set1_epi{{ intrin_tp[ctype][1] }}(value);"
   - target_extension: "avx2"
     ctype: ["uint64_t", "int64_t"]
     lscpu_flags: ["avx"]
     implementation: "return _mm256_set1_epi{{ intrin_tp[ctype][1] }}x(value);"
   - target_extension: "avx2"
     ctype: ["float", "double"]
     lscpu_flags: ["avx"]
     implementation: "return _mm256_set1_{{ intrin_tp_full[ctype] }}(value);"
#INTEL - SSE
   - target_extension: "sse"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "int8_t", "int16_t", "int32_t"]
     lscpu_flags: ["sse2"]
     implementation: "return _mm_set1_epi{{ intrin_tp[ctype][1] }}(value);"
   - target_extension: "sse"
     ctype: ["uint64_t", "int64_t"]
     lscpu_flags: ["sse2"]
     implementation: "return _mm_set1_epi{{ intrin_tp[ctype][1] }}x(value);"
   - target_extension: "sse"
     ctype: ["float"]
     lscpu_flags: ["sse"]
     implementation: "return _mm_set1_ps(value);"
   - target_extension: "sse"
     ctype: ["double"]
     lscpu_flags: ["sse2"]
     implementation: "return _mm_set1_pd(value);"
#ARM - NEON
   - target_extension: "neon"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
     lscpu_flags: [ 'neon' ]
     implementation: "return vdupq_n_{{ intrin_tp_full[ctype] }}( value );"
#SCALAR
   - target_extension: "scalar"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
     lscpu_flags: []
     implementation: "return value;"
#INTEL - FPGA
   - target_extension: "fpga"
     ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "float", "uint64_t", "int64_t", "double"]
     lscpu_flags: ["fpga"]
     vector_length_agnostic: True
     implementation: |
        using T = typename Vec::register_type;
        T result;
        #pragma unroll
        for(int i = 0; i < Vec::vector_element_count(); ++i) {
          result[i] = value;
        }
        return result;
...
---
primitive_name: "set"
brief_description: "Transfers provided elements into a vector register."
parameters:
  - ctype: "Ts"
    name: "args"
    description: "Values which should be transferred."
    is_parameter_pack: True
returns:
  ctype: "typename Vec::register_type"
  description: "Vector register containing the values."
testing:
  -  requires: ["storeu"]
     includes: ["<cstddef>", "<algorithm>", "<limits>"]
     implementation: |
       using T = typename Vec::base_type;
       std::size_t element_count = 1024;
       testing::test_memory_helper_t<Vec> test_helper{element_count, Vec::vector_element_count(), false};
       bool allOk = true;
       auto reference_data_ptr = test_helper.data_ref();
       auto reference_result_ptr = test_helper.result_ref();
       auto test_data_ptr = test_helper.data_target();
       auto test_result_ptr = test_helper.result_target();
       for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
          for(size_t j = i; j < i + Vec::vector_element_count(); ++j) {
             reference_result_ptr[j-i] = reference_data_ptr[j];
          }
          auto loaded = testing::set_call_helper_t<Vec>::call_set(&test_data_ptr[i]);
          storeu<Vec>(test_result_ptr, loaded);
          test_helper.synchronize();
          allOk &= test_helper.validate();
       }
       return allOk;
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ["avx512f"]
    implementation: "return _mm512_set_epi{{ intrin_tp[ctype][1] }}(args...);"
  - target_extension: "avx512"
    ctype: ["float", "double"]
    lscpu_flags: ["avx512f"]
    implementation: "return _mm512_set_{{ intrin_tp_full[ctype] }}(args...);"
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "int8_t", "int16_t", "int32_t"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_set_epi{{ intrin_tp[ctype][1] }}(args...);"
  - target_extension: "avx2"
    ctype: ["uint64_t", "int64_t"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_set_epi64x( args... );"
  - target_extension: "avx2"
    ctype: ["float", "double"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_set_{{ intrin_tp_full[ctype] }}(args...);"
  #INTEL - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "int8_t", "int16_t", "int32_t"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_set_epi{{ intrin_tp[ctype][1] }}(args...);"
  - target_extension: "sse"
    ctype: ["uint64_t", "int64_t"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_set_epi{{ intrin_tp[ctype][1] }}x(args...);"
  - target_extension: "sse"
    ctype: ["float"]
    lscpu_flags: ["sse"]
    implementation: "return _mm_set_{{ intrin_tp_full[ctype] }}(args...);"
  - target_extension: "sse"
    ctype: ["double"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_set_{{ intrin_tp_full[ctype] }}(args...);"
  #SCALAR
  - target_extension: "scalar"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: []
    implementation: "return std::get<0>(std::make_tuple(args...));"
...
---
primitive_name: "sequence"
brief_description: "Creates a sequence [0..SIMD-Reg-Element-Count]."
returns:
  ctype: "typename Vec::register_type"
  description: "Vector register containing the sequence."
definitions:
#  INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["avx512f"]
    implementation: |
      using T = typename Vec::base_type;
      using sequence_type = typename std::conditional_t<std::is_integral_v<T>, T, uint64_t>;
      auto seq_fun= []<sequence_type... Is>(
        std::integer_sequence<sequence_type, Is...>        
      ) {
        return tvl::set<Vec>(
          ((T)Is)...
        );
      };
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["avx"]
    implementation: |
      using T = typename Vec::base_type;
      using sequence_type = typename std::conditional_t<std::is_integral_v<T>, T, uint64_t>;
      auto seq_fun= []<sequence_type... Is>(
        std::integer_sequence<sequence_type, Is...>        
      ) {
        return tvl::set<Vec>(
          ((T)Is)...
        );
      };
  #INTEL - SSE
  - target_extension: "sse"
    ctype: [ "uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double" ]
    lscpu_flags: ["sse2"]
    implementation: |
      using T = typename Vec::base_type;
      using sequence_type = typename std::conditional_t<std::is_integral_v<T>, T, uint64_t>;
      auto seq_fun= []<sequence_type... Is>(
        std::integer_sequence<sequence_type, Is...>        
      ) {
        return tvl::set<Vec>(
          ((T)Is)...
        );
      };
  #SCALAR
  - target_extension: "scalar"
    ctype: [ "uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double" ]
    lscpu_flags: []
    implementation: "return 0;"
...
---
primitive_name: "custom_sequence"
brief_description: "Creates a sequence."
parameters:
  - ctype: "typename Vec::base_type"
    name: "start"
    description: "Start value for sequence."
    default_value: "0"
  - ctype: "typename Vec::base_type"
    name: "stepwidth"
    description: "Stepwidth."
    default_value: "1"
    declaration_attributes: "[[maybe_unused]]"
returns:
  ctype: "typename Vec::register_type"
  description: "Vector register containing the sequence."
definitions:
  #  INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["avx512f"]
    implementation: |
      using T = typename Vec::base_type;
      using sequence_type = typename std::conditional_t<std::is_integral_v<T>, T, uint64_t>;
      auto seq_fun= []<sequence_type... Is>(
        T const max, T const init, T const sw, std::integer_sequence<sequence_type, Is...>        
      ) {
        return tvl::set<Vec>(
          ((max-((T)(Is+1))*sw)+init)...
        );
      };
      return seq_fun(Vec::vector_element_count()*stepwidth+start, start, stepwidth, std::make_integer_sequence<sequence_type, Vec::vector_element_count()>());
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["avx"]
    implementation: |
      using T = typename Vec::base_type;
      using sequence_type = typename std::conditional_t<std::is_integral_v<T>, T, uint64_t>;
      auto seq_fun= []<sequence_type... Is>(
        T const max, T const init, T const sw, std::integer_sequence<sequence_type, Is...>        
      ) {
        return tvl::set<Vec>(
          ((max-((T)(Is+1))*sw)+init)...
        );
      };
      return seq_fun(Vec::vector_element_count()*stepwidth+start, start, stepwidth, std::make_integer_sequence<sequence_type, Vec::vector_element_count()>());
  #INTEL - SSE
  - target_extension: "sse"
    ctype: [ "uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double" ]
    lscpu_flags: ["sse2"]
    implementation: |
      using T = typename Vec::base_type;
      using sequence_type = typename std::conditional_t<std::is_integral_v<T>, T, uint64_t>;
      auto seq_fun= []<sequence_type... Is>(
        T const max, T const init, T const sw, std::integer_sequence<sequence_type, Is...>        
      ) {
        return tvl::set<Vec>(
          ((max-((T)(Is+1))*sw)+init)...
        );
      };
      return seq_fun(Vec::vector_element_count()*stepwidth+start, start, stepwidth, std::make_integer_sequence<sequence_type, Vec::vector_element_count()>());
  #SCALAR
  - target_extension: "scalar"
    ctype: [ "uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double" ]
    lscpu_flags: []
    implementation: "return start;"
...
---
primitive_name: "mask_gather"
brief_description: "Transfers data from arbitrary locations into a vector register."
additional_non_specialized_template_parameters:
  - ctype: "int"
    name: "N"
parameters:
  - ctype: "const typename Vec::mask_type"
    name: "mask"
    description: "Mask indicating which lanes should be gathered."
  - ctype: "const typename Vec::register_type"
    name: "source"
    description: "Vector register containing values which should be preserved depending on the mask (if mask[i] == 0)."
  - ctype: "const typename Vec::base_type *"
    attributes: "__restrict__"
    name: "memory"
    description: "(Start)pointer of the memory (which is used as base for address calculation)."
  - ctype: "const typename Vec::offset_base_register_type"
    name: "index"
    description: "Offsets array containing simd<offset_t, EXTENSION> register_types containing relative offsets to the start pointer (the number of array elements depend on the sizeof(offset_type)/sizeof(base_type) ratio, where sizeof(offset_type) should be 8)."
  - ctype: "std::integral_constant<int, N>"
    name: "scale"
    description: "Scale."
    declaration_attributes: "[[maybe_unused]]"
returns:
  ctype: "typename Vec::register_type"
  description: "Vector containing gathered data."
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint32_t", "uint64_t", "int32_t", "int64_t"]
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_mask_i64gather_epi64( source, mask, index, reinterpret_cast< void const * >( memory ), scale() );"
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint64_t", "int64_t"]
    lscpu_flags: ["avx2"]
    implementation: "return _mm256_mask_i64gather_epi64(source, reinterpret_cast<long long int const *>(memory), index, mask, scale());"
  - target_extension: "avx2"
    ctype: ["uint32_t", "int32_t"]
    lscpu_flags: ["avx2"]
    implementation: "return _mm256_mask_i32gather_epi32(source, reinterpret_cast<long long int const *>(memory), index, mask, scale());"
  - target_extension: "avx2"
    ctype: ["float"]
    lscpu_flags: ["avx2"]
    implementation: "return _mm256_mask_i32gather_ps(source, reinterpret_cast<float const *>(memory), index, mask, scale());"
  - target_extension: "avx2"
    ctype: ["double"]
    lscpu_flags: ["avx2"]
    implementation: "return _mm256_mask_i64gather_pd(source, reinterpret_cast<double const *>(memory), index, mask, scale());"
  #INTEL - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: [ 'sse2' ]
    implementation: "return tvl::set<Vec>((mask[1] == 0) ? source[1] : memory[index[1]], (mask[0] == 0) ? source[0] : memory[index[0]]);"
    is_native: False
  #ARM - NEON
  - target_extension: "neon"
    ctype: "int64_t"
    lscpu_flags: [ 'neon' ]
    is_native: False
    implementation: >
      auto tmp = vdupq_n_s64( ( mask[ 0 ] == 0 ) ? source[ 0 ] : memory[ index[ 0 ][ 0 ] ] );
                  return vsetq_lane_s64( ( ( mask[ 1 ] == 0 ) ? source[ 1 ] : memory[ index[ 0 ][ 1 ] ] ), tmp, 1 );
  #SCALAR
  - target_extension: "scalar"
    ctype: [ "uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double" ]
    lscpu_flags: [ ]
    implementation: "return (mask&1)==1 ? memory[index] : source;"
...
---
primitive_name: "mask_scatter"
brief_description: "Transfers data from arbitrary locations into a vector register."
additional_non_specialized_template_parameters:
  - ctype: "int"
    name: "N"
parameters:
  - ctype: "const typename Vec::mask_type"
    name: "mask"
    description: "Mask indicating which lanes should be gathered."
  - ctype: "const typename Vec::register_type"
    name: "data"
    description: "Vector register containing values which should be preserved depending on the mask (if mask[i] == 0)."
  - ctype: "typename Vec::base_type *"
    attributes: "__restrict__"
    name: "memory"
    description: "(Start)pointer of the memory (which is used as base for address calculation)."
  - ctype: "const typename Vec::offset_base_register_type"
    name: "index"
    description: "Offsets array containing simd<offset_t, EXTENSION> register_types containing relative offsets to the start pointer (the number of array elements depend on the sizeof(offset_type)/sizeof(base_type) ratio, where sizeof(offset_type) should be 8)."
  - ctype: "std::integral_constant<int, N>"
    name: "scale"
    description: "Scale."
    declaration_attributes: "[[maybe_unused]]"
definitions:
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["avx2"]
    is_native: False
    includes: ["<array>"]
    implementation: |
      alignas(Vec::vector_size_B()) std::array<typename Vec::offset_base_type, Vec::vector_element_count()> idx_array{};
      alignas(Vec::vector_size_B()) std::array<typename Vec::base_type, Vec::vector_element_count()> val_array{};
      alignas(Vec::vector_size_B()) std::array<typename Vec::base_type, Vec::vector_element_count()> mask_array{};
      tvl::store<Vec>(val_array.data(), data);
      tvl::store<typename Vec::transform_extension<Vec::offset_base_type>>(idx_array.data(), index);
      tvl::store<Vec>(mask_array.data(), mask);
      #pragma unroll
      for(int i = 0; i < Vec::vector_element_count(); ++i) {
        if(mask_array[i] != 0) {
          if constexpr(N==sizeof(typename Vec::base_type)) {
            memory[idx_array[i]] = val_array[i];
          } else {
            if constexpr(N==1) {
              *reinterpret_cast<typename Vec::base_type*>(reinterpret_cast<uint8_t*>(memory)[idx_array[i]]) = val_array[i];
            } else {
              *reinterpret_cast<typename Vec::base_type*>(reinterpret_cast<uint8_t*>(memory)[(idx_array[i]<<(cilog2(N)))]) = val_array[i];
            }
          }
        }        
      }
  #INTEL - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: [ 'sse2' ]
    includes: ["<array>"]
    is_native: False
    implementation: |
      alignas(Vec::vector_size_B()) std::array<typename Vec::offset_base_type, Vec::vector_element_count()> idx_array{};
      alignas(Vec::vector_size_B()) std::array<typename Vec::base_type, Vec::vector_element_count()> val_array{};
      alignas(Vec::vector_size_B()) std::array<typename Vec::base_type, Vec::vector_element_count()> mask_array{};
      tvl::store<Vec>(val_array.data(), data);
      tvl::store<typename Vec::transform_extension<Vec::offset_base_type>>(idx_array.data(), index);
      tvl::store<Vec>(mask_array.data(), mask);
      #pragma unroll
      for(int i = 0; i < Vec::vector_element_count(); ++i) {
        if(mask_array[i] != 0) {
          if constexpr(N==sizeof(typename Vec::base_type)) {
            memory[idx_array[i]] = val_array[i];
          } else {
            if constexpr(N==1) {
              *reinterpret_cast<typename Vec::base_type*>(reinterpret_cast<uint8_t*>(memory)[idx_array[i]]) = val_array[i];
            } else {
              *reinterpret_cast<typename Vec::base_type*>(reinterpret_cast<uint8_t*>(memory)[(idx_array[i]<<(cilog2(N)))]) = val_array[i];
            }
          }
        }        
      }
  #ARM - NEON
  - target_extension: "neon"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: [ 'neon' ]
    includes: ["<array>"]
    is_native: False
    implementation: |
      alignas(Vec::vector_size_B()) std::array<typename Vec::offset_base_type, Vec::vector_element_count()> idx_array{};
      alignas(Vec::vector_size_B()) std::array<typename Vec::base_type, Vec::vector_element_count()> val_array{};
      alignas(Vec::vector_size_B()) std::array<typename Vec::base_type, Vec::vector_element_count()> mask_array{};
      tvl::store<Vec>(val_array.data(), data);
      tvl::store<typename Vec::transform_extension<Vec::offset_base_type>>(idx_array.data(), index);
      tvl::store<Vec>(mask_array.data(), mask);
      #pragma unroll
      for(int i = 0; i < Vec::vector_element_count(); ++i) {
        if(mask_array[i] != 0) {
          if constexpr(N==sizeof(typename Vec::base_type)) {
            memory[idx_array[i]] = val_array[i];
          } else {
            if constexpr(N==1) {
              *reinterpret_cast<typename Vec::base_type*>(reinterpret_cast<uint8_t*>(memory)[idx_array[i]]) = val_array[i];
            } else {
              *reinterpret_cast<typename Vec::base_type*>(reinterpret_cast<uint8_t*>(memory)[(idx_array[i]<<(cilog2(N)))]) = val_array[i];
            }
          }
        }        
      }
  #SCALAR
  - target_extension: "scalar"
    ctype: [ "uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double" ]
    lscpu_flags: [ ]
    implementation: |
      if((mask&0b1) != 0) {
        if constexpr(N==sizeof(typename Vec::base_type)) {
          memory[index] = data;
        } else {
          if constexpr(N==1) {
            *reinterpret_cast<typename Vec::base_type*>(reinterpret_cast<uint8_t*>(memory)[index]) = data;
          } else {
            *reinterpret_cast<typename Vec::base_type*>(reinterpret_cast<uint8_t*>(memory)[(index<<(cilog2(N)))]) = data;
          }
        }
      }
...
#---
#primitive_name: "gather"
#additional_simd_template_parameter: "OffsetType"
#brief_description: "Transfers data from arbitrary locations into a vector register."
#additional_non_specialized_template_parameters:
#  - ctype: "int"
#    name: "N"
#parameters:
#  - ctype: "const typename Vec::base_type *"
#    attributes: "__restrict__"
#    name: "memory"
#    description: "(Start)pointer of the memory (which is used as base for address calculation)."
#  - ctype: "const std::array<typename OffsetType::register_type, sizeof(typename OffsetType::base_type)/sizeof(Vec::base_type)> &"
#    name: "indices"
#    description: "Offsets array containing simd<offset_t, EXTENSION> register_types containing relative offsets to the start pointer (the number of array elements depend on the sizeof(offset_type)/sizeof(base_type) ratio, where sizeof(offset_type) should be 8)."
#  - ctype: "std::integral_constant<int, N>"
#    name: "scale"
#    description: "Scale."
#returns:
#  ctype: "typename Vec::register_type"
#  description: "Vector containing gathered data."
#definitions:
##INTEL - AVX2
#  - target_extension: "avx2"
#    ctype: ["uint8_t", "int8_t"]
#    additional_simd_template_base_type: ["uint32_t"]
#    lscpu_flags: ['avx2']
#    implementation: |
#      auto base_addr = reinterpret_cast<int const*>(memory);
#      _mm256_i32gather_epi32(base_addr, indices[0], scale());
#      return _mm512_mask_i64gather_epi64( source, mask, index[0], reinterpret_cast< void const * >( memory ), scale() );
#...
#---
#primitive_name: "vcompress"
#brief_description: ""
