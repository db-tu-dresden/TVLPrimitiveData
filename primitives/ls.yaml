---
name: "ls"
description: "Load/Store primitives"
...
---
primitive_name: "load"
brief_description: "Loads data from aligned memory into a vector register."
parameters:
   - ctype: "const typename Vec::base_type *"
     name: "memory"
     description: "Aligned memory which should be transferred into a vector register."
returns:
   ctype: "typename Vec::register_type"
   description: "Vector containing the loaded data."
testing:
   -  requires: ["storeu"]
      includes: ["<cstddef>", "<cstring>"]
      implementation: |
         using T = typename Vec::base_type;
         std::size_t element_count = 1024;
         testing::test_memory_helper_t<Vec> test_helper{element_count, Vec::vector_element_count(), true};
         bool allOk = true;
         auto reference_data_ptr = test_helper.data_ref();
         auto reference_result_ptr = test_helper.result_ref();
         auto test_data_ptr = test_helper.data_target();
         auto test_result_ptr = test_helper.result_target();
         for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
            for(size_t j = i; j < i + Vec::vector_element_count(); ++j) {
               reference_result_ptr[j-i] = reference_data_ptr[j];
            }
            auto loaded = load<Vec>(&test_data_ptr[i]);
            storeu<Vec>(test_result_ptr, loaded);
            test_helper.synchronize();
            allOk &= test_helper.validate();
         }
         return allOk;
definitions:
#INTEL - AVX512
   - target_extension: "avx512"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ["avx512f"]
     implementation: "return _mm512_load_si512(reinterpret_cast<void const *>(assume_aligned<Vec::vector_alignment()>(memory)));"
   - target_extension: "avx512"
     ctype: ["float", "double"]
     lscpu_flags: ["avx512f"]
     implementation: "return _mm512_load_{{ intrin_tp_full[ctype] }}(reinterpret_cast<void const *>(assume_aligned<Vec::vector_alignment()>(memory)));"
#INTEL - AVX2
   - target_extension: "avx2"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ["avx"]
     implementation: "return _mm256_load_si256(reinterpret_cast<__m256i const *>(assume_aligned<Vec::vector_alignment()>(memory)));"
   - target_extension: "avx2"
     ctype: ["float", "double"]
     lscpu_flags: ["avx"]
     implementation: "return _mm256_load_{{ intrin_tp_full[ctype] }}(assume_aligned<Vec::vector_alignment()>(memory));"
#INTEL - SSE
   - target_extension: "sse"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ["sse2"]
     implementation: "return _mm_load_si128(reinterpret_cast<__m128i const *>(assume_aligned<Vec::vector_alignment()>(memory)));"
   - target_extension: "sse"
     ctype: ["float"]
     lscpu_flags: ["sse"]
     implementation: "return _mm_load_ps(assume_aligned<Vec::vector_alignment()>(memory));"
   - target_extension: "sse"
     ctype: ["double"]
     lscpu_flags: ["sse2"]
     implementation: "return _mm_load_pd(assume_aligned<Vec::vector_alignment()>(memory));"
#ARM - NEON
   - target_extension: "neon"
     ctype: "int64_t"
     lscpu_flags: ["neon"]
     implementation: "return vld1q_{{ intrin_tp_full[ctype] }}(assume_aligned<Vec::vector_alignment()>(memory));"
#SCALAR
   - target_extension: "scalar"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
     lscpu_flags: []
     implementation: "return *memory;"
#FPGA
   - target_extension: "fpga"
     ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "float", "uint64_t", "int64_t", "double"]
     lscpu_flags: ["fpga"]
     vector_length_agnostic: True
     implementation: |
        using T = typename Vec::register_type;
        T reg; //initialize the result
        auto mem = assume_aligned<Vec::vector_alignment()>(memory);
        #pragma unroll
        for (size_t idx = 0; idx < Vec::vector_element_count(); idx++) {
          reg[idx] = mem[idx];
        }
        return reg;
...
---
primitive_name: "loadu"
brief_description: "Loads data from (un)aligned memory into a vector register."
parameters:
   - ctype: "const typename Vec::base_type *"
     name: "memory"
     description: "(Un)aligned memory which should be transferred into a vector register."
returns:
   ctype: "typename Vec::register_type"
   description: "Vector containing the loaded data."
testing:
   -  requires: ["storeu"]
      includes: ["<cstddef>", "<cstring>"]
      implementation: |
         using T = typename Vec::base_type;
         std::size_t element_count = 1024;
         testing::test_memory_helper_t<Vec> test_helper{element_count, Vec::vector_element_count(), false};
         bool allOk = true;
         auto reference_data_ptr = test_helper.data_ref();
         auto reference_result_ptr = test_helper.result_ref();
         auto test_data_ptr = test_helper.data_target();
         auto test_result_ptr = test_helper.result_target();
         for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); ++i) {
            for(size_t j = i; j < i + Vec::vector_element_count(); ++j) {
               reference_result_ptr[j-i] = reference_data_ptr[j];
            }
            auto loaded = loadu<Vec>(&test_data_ptr[i]);
            storeu<Vec>(test_result_ptr, loaded);
            test_helper.synchronize();
            allOk &= test_helper.validate();
         }
         return allOk;
definitions:
#INTEL - AVX512
   - target_extension: "avx512"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ["avx512f"]
     implementation: "return _mm512_loadu_si512(reinterpret_cast<void const *>(memory));"
   - target_extension: "avx512"
     ctype: ["float", "double"]
     lscpu_flags: ["avx512f"]
     implementation: "return _mm512_loadu_{{ intrin_tp_full[ctype] }}(reinterpret_cast<void const *>(memory));"
#INTEL - AVX2
   - target_extension: "avx2"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ['avx']
     implementation: "return _mm256_loadu_si256( reinterpret_cast< __m256i const * >( memory ) );"
   - target_extension: "avx2"
     ctype: ["float", "double"]
     lscpu_flags: ["avx"]
     implementation: "return _mm256_loadu_{{ intrin_tp_full[ctype] }}(memory);"
#INTEL - SSE
   - target_extension: "sse"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ["sse2"]
     implementation: "return _mm_loadu_si128(reinterpret_cast<__m128i const *>(memory));"
   - target_extension: "sse"
     ctype: ["float"]
     lscpu_flags: ["sse"]
     implementation: "return _mm_loadu_ps(memory);"
   - target_extension: "sse"
     ctype: ["double"]
     lscpu_flags: ["sse2"]
     implementation: "return _mm_loadu_pd(memory);"
#ARM - NEON
   - target_extension: "neon"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
     lscpu_flags: [ 'neon' ]
     implementation: "return vld1q_{{ intrin_tp_full[ctype] }}(memory);"
#SCALAR
   - target_extension: "scalar"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
     lscpu_flags: []
     implementation: "return *memory;"
#FPGA
   - target_extension: "fpga"
     ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "float", "uint64_t", "int64_t", "double"]
     lscpu_flags: ["fpga"]
     vector_length_agnostic: True
     implementation: |
        using T = typename Vec::register_type;
        T reg; //initialize the result
        #pragma unroll
        for (size_t idx = 0; idx < Vec::vector_element_count(); idx++) {
          reg[idx] = memory[idx];
        }
        return reg;
...
---
primitive_name: "store"
brief_description: "Stores data from a vector register to aligned memory."
parameters:
   - ctype: "typename Vec::base_type *"
     name: "memory"
     description: "Aligned memory where the data should be stored into."
   - ctype: "const typename Vec::register_type"
     name: "data"
     description: "Vector containing the data."
testing:
   -  requires: ["set1"]
      includes: ["<cstddef>", "<cstring>"]
      implementation: |
         using T = typename Vec::base_type;
         std::size_t element_count = 1024;
         testing::test_memory_helper_t<Vec> test_helper{Vec::vector_element_count(), true};
         bool allOk = true;
         auto reference_data_ptr = test_helper.data_ref();
         auto reference_result_ptr = test_helper.result_ref();
         auto test_data_ptr = test_helper.data_target();
         auto test_result_ptr = test_helper.result_target();
         for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
            for(size_t j = i; j < i + Vec::vector_element_count(); ++j) {
               reference_result_ptr[j-i] = i;
            }
            auto loaded = set1<Vec>(i);
            store<Vec>(test_result_ptr, loaded);
            test_helper.synchronize();
            allOk &= test_helper.validate();
         }
         return allOk;
definitions:
#INTEL - AVX512
   - target_extension: "avx512"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ["avx512f"]
     implementation: "_mm512_store_si512(reinterpret_cast<void *>(assume_aligned<Vec::vector_alignment()>(memory)), data);"
   - target_extension: "avx512"
     ctype: ["float", "double"]
     lscpu_flags: ["avx512f"]
     implementation: "_mm512_store_{{ intrin_tp_full[ctype] }}(reinterpret_cast<void *>(assume_aligned<Vec::vector_alignment()>(memory)), data);"
#INTEL - AVX2
   - target_extension: "avx2"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ["avx"]
     implementation: "_mm256_store_si256(reinterpret_cast<__m256i *>(assume_aligned<Vec::vector_alignment()>(memory)), data);"
   - target_extension: "avx2"
     ctype: ["float", "double"]
     lscpu_flags: ["avx"]
     implementation: "_mm256_store_{{ intrin_tp_full[ctype] }}(assume_aligned<Vec::vector_alignment()>(memory), data);"
#INTEL - SSE
   - target_extension: "sse"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ["sse2"]
     implementation: "_mm_store_si128(reinterpret_cast<__m128i *>(assume_aligned<Vec::vector_alignment()>(memory)), data);"
   - target_extension: "sse"
     ctype: ["float"]
     lscpu_flags: ["sse"]
     implementation: "_mm_store_ps(assume_aligned<Vec::vector_alignment()>(memory), data);"
   - target_extension: "sse"
     ctype: ["double"]
     lscpu_flags: ["sse2"]
     implementation: "_mm_store_pd(assume_aligned<Vec::vector_alignment()>(memory), data);"
#ARM - NEON
   - target_extension: "neon"
     ctype: "int64_t"
     lscpu_flags: ["neon"]
     implementation: "vst1q_{{ intrin_tp_full[ctype] }}(assume_aligned<Vec::vector_alignment()>(memory), data);"
#SCALAR
   - target_extension: "scalar"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
     lscpu_flags: []
     implementation: "*memory = data;"
#FPGA
   - target_extension: "fpga"
     ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "float", "uint64_t", "int64_t", "double"]
     lscpu_flags: ["fpga"]
     vector_length_agnostic: True
     implementation: |
        #pragma unroll
        for (size_t idx = 0; idx < Vec::vector_element_count(); idx++) {
          memory[idx] = data[idx];
        }
...
---
primitive_name: "storeu"
brief_description: "Stores data from a vector register to (un)aligned memory."
parameters:
   - ctype: "typename Vec::base_type *"
     name: "memory"
     description: "(Un)aligned memory where the data should be stored into."
   - ctype: "const typename Vec::register_type"
     name: "data"
     description: "Vector containing the data."
testing:
   -  requires: ["set1"]
      includes: ["<cstddef>", "<cstring>"]
      implementation: |
         using T = typename Vec::base_type;
         std::size_t element_count = 1024;
         testing::test_memory_helper_t<Vec> test_helper{Vec::vector_element_count(), false};
         bool allOk = true;
         auto reference_result_ptr = test_helper.result_ref();
         auto test_result_ptr = test_helper.result_target();
         for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
            for(size_t j = i; j < i + Vec::vector_element_count(); ++j) {
               reference_result_ptr[j-i] = i;
            }
            auto loaded = set1<Vec>(i);
            storeu<Vec>(test_result_ptr, loaded);
            test_helper.synchronize();
            allOk &= test_helper.validate();
         }
         return allOk;
definitions:
#INTEL - AVX512
   - target_extension: "avx512"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ["avx512f"]
     implementation: "_mm512_storeu_si512(reinterpret_cast<void *>(memory), data);"
   - target_extension: "avx512"
     ctype: ["float", "double"]
     lscpu_flags: ["avx512f"]
     implementation: "_mm512_storeu_{{ intrin_tp_full[ctype] }}(reinterpret_cast<void *>(memory), data);"
#INTEL - AVX2
   - target_extension: "avx2"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ["avx"]
     implementation: "_mm256_storeu_si256(reinterpret_cast<__m256i *>(memory), data);"
   - target_extension: "avx2"
     ctype: ["float", "double"]
     lscpu_flags: ["avx"]
     implementation: "_mm256_storeu_{{ intrin_tp_full[ctype] }}(memory, data);"
#INTEL - SSE
   - target_extension: "sse"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ["sse2"]
     implementation: "_mm_storeu_si128(reinterpret_cast<__m128i *>(memory), data);"
   - target_extension: "sse"
     ctype: ["float"]
     lscpu_flags: ["sse"]
     implementation: "_mm_storeu_ps(memory, data);"
   - target_extension: "sse"
     ctype: ["double"]
     lscpu_flags: ["sse2"]
     implementation: "_mm_storeu_pd(memory, data);"
#ARM - NEON
   - target_extension: "neon"
     ctype: "int64_t"
     lscpu_flags: ["neon"]
     implementation: "vst1q_{{ intrin_tp_full[ctype] }}(memory, data);"
#SCALAR
   - target_extension: "scalar"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
     lscpu_flags: []
     implementation: "*memory = data;"
#FPGA
   - target_extension: "fpga"
     ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "float", "uint64_t", "int64_t", "double"]
     lscpu_flags: ["fpga"]
     vector_length_agnostic: True
     implementation: |
        #pragma unroll
        for (size_t idx = 0; idx < Vec::vector_element_count(); idx++) {
          memory[idx] = data[idx];
        }
...
---
primitive_name: "to_array"
brief_description: "Stores SIMD register to array."
parameters:
  - ctype: "const typename Vec::register_type"
    name: "data"
    description: "Data register."
returns:
  ctype: "__attribute__((__aligned__(Vec::vector_alignment()))) std::array<typename Vec::base_type, Vec::vector_element_count()>"
  description: "Array containing the values from data."
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: ["avx512f"]
    implementation: |
      alignas(Vec::vector_alignment()) std::array<typename Vec::base_type, Vec::vector_element_count()> tmp{};
      tvl::store<Vec>(assume_aligned<Vec::vector_alignment()>(tmp.data()), data);
      return tmp;
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: ["avx2"]
    implementation: |
      alignas(Vec::vector_alignment()) std::array<typename Vec::base_type, Vec::vector_element_count()> tmp{};
      tvl::store<Vec>(assume_aligned<Vec::vector_alignment()>(tmp.data()), data);
      return tmp;
  #INTEL - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: ["sse2"]
    implementation: |
      alignas(Vec::vector_alignment()) std::array<typename Vec::base_type, Vec::vector_element_count()> tmp{};
      tvl::store<Vec>(assume_aligned<Vec::vector_alignment()>(tmp.data()), data);
      return tmp;
---
primitive_name: "set1"
brief_description: "Broadcasts a single value into all lanes of a vector register."
parameters:
   - ctype: "const typename Vec::base_type"
     name: "value"
     description: "Value which should be broadcasted."
returns:
   ctype: "typename Vec::register_type"
   description: "Vector containing the same value in all lanes."
testing:
   -
      includes: ["<cstddef>", "<algorithm>", "<limits>"]
      implementation: |
         std::size_t element_count = 1024;
         bool allOk = true;
         testing::test_memory_helper_t<Vec> test_helper{Vec::vector_element_count(), false};
         const std::size_t limit = std::min((std::size_t) 4096, (std::size_t) std::numeric_limits<typename Vec::base_type>::max());
         auto reference_result_ptr = test_helper.result_ref();
         auto test_result_ptr = test_helper.result_target();
         for(std::size_t i = 0; i < limit; ++i) {
            auto vec = set1<Vec>(i);
            for(std::size_t j = 0; j < Vec::vector_element_count(); j++) {
               reference_result_ptr[j] = i;
            }
            allOk &= test_helper.validate_simd_register(vec);
         }
         const auto maxval = std::numeric_limits<typename Vec::base_type>::max();
         auto max_vec = set1<Vec>(maxval);
         for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
            reference_result_ptr[i] = maxval;
         }
         allOk &= test_helper.validate_simd_register(max_vec);
         return allOk;
definitions:
#INTEL - AVX512
   - target_extension: "avx512"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
     lscpu_flags: ["avx512f"]
     implementation: "return _mm512_set1_epi{{ intrin_tp[ctype][1] }}(value);"
   - target_extension: "avx512"
     ctype: ["float", "double"]
     lscpu_flags: ["avx512f"]
     implementation: "return _mm512_set1_{{ intrin_tp_full[ctype] }}(value);"
#INTEL - AVX2
   - target_extension: "avx2"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "int8_t", "int16_t", "int32_t"]
     lscpu_flags: ["avx"]
     implementation: "return _mm256_set1_epi{{ intrin_tp[ctype][1] }}(value);"
   - target_extension: "avx2"
     ctype: ["uint64_t", "int64_t"]
     lscpu_flags: ["avx"]
     implementation: "return _mm256_set1_epi{{ intrin_tp[ctype][1] }}x(value);"
   - target_extension: "avx2"
     ctype: ["float", "double"]
     lscpu_flags: ["avx"]
     implementation: "return _mm256_set1_{{ intrin_tp_full[ctype] }}(value);"
#INTEL - SSE
   - target_extension: "sse"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "int8_t", "int16_t", "int32_t"]
     lscpu_flags: ["sse2"]
     implementation: "return _mm_set1_epi{{ intrin_tp[ctype][1] }}(value);"
   - target_extension: "sse"
     ctype: ["uint64_t", "int64_t"]
     lscpu_flags: ["sse2"]
     implementation: "return _mm_set1_epi{{ intrin_tp[ctype][1] }}x(value);"
   - target_extension: "sse"
     ctype: ["float"]
     lscpu_flags: ["sse"]
     implementation: "return _mm_set1_ps(value);"
   - target_extension: "sse"
     ctype: ["double"]
     lscpu_flags: ["sse2"]
     implementation: "return _mm_set1_pd(value);"
#ARM - NEON
   - target_extension: "neon"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
     lscpu_flags: [ 'neon' ]
     implementation: "return vdupq_n_{{ intrin_tp_full[ctype] }}( value );"
#SCALAR
   - target_extension: "scalar"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
     lscpu_flags: []
     implementation: "return value;"
#INTEL - FPGA
   - target_extension: "fpga"
     ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "float", "uint64_t", "int64_t", "double"]
     lscpu_flags: ["fpga"]
     vector_length_agnostic: True
     implementation: |
        using T = typename Vec::register_type;
        T result;
        #pragma unroll
        for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
          result[i] = value;
        }
        return result;
...
---
primitive_name: "set_zero"
brief_description: "Set all lanes to zero."
returns:
  ctype: "typename Vec::register_type"
  description: "Vector containing 0 in all lanes."
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ["avx512f"]
    implementation: "return _mm512_setzero_si512();"
  - target_extension: "avx512"
    ctype: ["float", "double"]
    lscpu_flags: ["avx512f"]
    implementation: "return _mm512_setzero_{{ intrin_tp_full[ctype] }}();"
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_setzero_si256();"
  - target_extension: "avx2"
    ctype: ["float", "double"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_setzero_{{ intrin_tp_full[ctype] }}();"
  #INTEL - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_setzero_si128();"
  - target_extension: "sse"
    ctype: ["float", "double"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_setzero_{{ intrin_tp_full[ctype] }}();"
---
primitive_name: "set"
brief_description: "Transfers provided elements into a vector register."
parameters:
  - ctype: "Ts"
    name: "args"
    description: "Values which should be transferred."
    is_parameter_pack: True
returns:
  ctype: "typename Vec::register_type"
  description: "Vector register containing the values."
testing:
  -  requires: ["storeu"]
     includes: ["<cstddef>", "<algorithm>", "<limits>"]
     implementation: |
       using T = typename Vec::base_type;
       std::size_t element_count = 1024;
       testing::test_memory_helper_t<Vec> test_helper{element_count, Vec::vector_element_count(), false};
       bool allOk = true;
       auto reference_data_ptr = test_helper.data_ref();
       auto reference_result_ptr = test_helper.result_ref();
       auto test_data_ptr = test_helper.data_target();
       auto test_result_ptr = test_helper.result_target();
       for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
          for(size_t j = i; j < i + Vec::vector_element_count(); ++j) {
             reference_result_ptr[j-i] = reference_data_ptr[j];
          }
          auto loaded = testing::set_call_helper_t<Vec>::call_set(&test_data_ptr[i]);
          storeu<Vec>(test_result_ptr, loaded);
          test_helper.synchronize();
          allOk &= test_helper.validate();
       }
       return allOk;
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ["avx512f"]
    implementation: "return _mm512_set_epi{{ intrin_tp[ctype][1] }}(args...);"
  - target_extension: "avx512"
    ctype: ["float", "double"]
    lscpu_flags: ["avx512f"]
    implementation: "return _mm512_set_{{ intrin_tp_full[ctype] }}(args...);"
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "int8_t", "int16_t", "int32_t"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_set_epi{{ intrin_tp[ctype][1] }}(args...);"
  - target_extension: "avx2"
    ctype: ["uint64_t", "int64_t"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_set_epi64x( args... );"
  - target_extension: "avx2"
    ctype: ["float", "double"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_set_{{ intrin_tp_full[ctype] }}(args...);"
  #INTEL - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "int8_t", "int16_t", "int32_t"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_set_epi{{ intrin_tp[ctype][1] }}(args...);"
  - target_extension: "sse"
    ctype: ["uint64_t", "int64_t"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_set_epi{{ intrin_tp[ctype][1] }}x(args...);"
  - target_extension: "sse"
    ctype: ["float"]
    lscpu_flags: ["sse"]
    implementation: "return _mm_set_{{ intrin_tp_full[ctype] }}(args...);"
  - target_extension: "sse"
    ctype: ["double"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_set_{{ intrin_tp_full[ctype] }}(args...);"
  #SCALAR
  - target_extension: "scalar"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: []
    implementation: "return std::get<0>(std::make_tuple(args...));"
...
---
primitive_name: "sequence"
brief_description: "Creates a sequence [0..SIMD-Reg-Element-Count]."
returns:
  ctype: "typename Vec::register_type"
  description: "Vector register containing the sequence."
definitions:
#  INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["avx512f"]
    implementation: |
      using T = typename Vec::base_type;
      using sequence_type = typename std::conditional_t<std::is_integral_v<T>, T, uint64_t>;
      auto seq_fun= []<sequence_type... Is>(
        std::integer_sequence<sequence_type, Is...>        
      ) {
        return tvl::set<Vec>(
          ((T)Is)...
        );
      };
      return seq_fun(std::make_integer_sequence<sequence_type, Vec::vector_element_count()>());
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["avx"]
    implementation: |
      using T = typename Vec::base_type;
      using sequence_type = typename std::conditional_t<std::is_integral_v<T>, T, uint64_t>;
      auto seq_fun= []<sequence_type... Is>(
        std::integer_sequence<sequence_type, Is...>        
      ) {
        return tvl::set<Vec>(
          ((T)Is)...
        );
      };
      return seq_fun(std::make_integer_sequence<sequence_type, Vec::vector_element_count()>());
  #INTEL - SSE
  - target_extension: "sse"
    ctype: [ "uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double" ]
    lscpu_flags: ["sse2"]
    implementation: |
      using T = typename Vec::base_type;
      using sequence_type = typename std::conditional_t<std::is_integral_v<T>, T, uint64_t>;
      auto seq_fun= []<sequence_type... Is>(
        std::integer_sequence<sequence_type, Is...>        
      ) {
        return tvl::set<Vec>(
          ((T)Is)...
        );
      };
      return seq_fun(std::make_integer_sequence<sequence_type, Vec::vector_element_count()>());
  #SCALAR
  - target_extension: "scalar"
    ctype: [ "uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double" ]
    lscpu_flags: []
    implementation: "return 0;"
...
---
primitive_name: "custom_sequence"
brief_description: "Creates a sequence."
parameters:
  - ctype: "typename Vec::base_type"
    name: "start"
    description: "Start value for sequence."
    default_value: "0"
  - ctype: "typename Vec::base_type"
    name: "stepwidth"
    description: "Stepwidth."
    default_value: "1"
    declaration_attributes: "[[maybe_unused]]"
returns:
  ctype: "typename Vec::register_type"
  description: "Vector register containing the sequence."
definitions:
  #  INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["avx512f"]
    implementation: |
      using T = typename Vec::base_type;
      using sequence_type = typename std::conditional_t<std::is_integral_v<T>, T, uint64_t>;
      auto seq_fun= []<sequence_type... Is>(
        T const init, T const sw, std::integer_sequence<sequence_type, Is...>        
      ) {
        return tvl::set<Vec>(
          ((((T)(sizeof...(Is) - 1 - Is))*sw)+init)...
        );
      };
      return seq_fun(start, stepwidth, std::make_integer_sequence<sequence_type, Vec::vector_element_count()>());
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["avx"]
    implementation: |
      using T = typename Vec::base_type;
      using sequence_type = typename std::conditional_t<std::is_integral_v<T>, T, uint64_t>;
      auto seq_fun= []<sequence_type... Is>(
        T const init, T const sw, std::integer_sequence<sequence_type, Is...>        
      ) {
        return tvl::set<Vec>(
          ((((T)(sizeof...(Is) - 1 - Is))*sw)+init)...
        );
      };
      return seq_fun(start, stepwidth, std::make_integer_sequence<sequence_type, Vec::vector_element_count()>());
  #INTEL - SSE
  - target_extension: "sse"
    ctype: [ "uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double" ]
    lscpu_flags: ["sse2"]
    implementation: |
      using T = typename Vec::base_type;
      using sequence_type = typename std::conditional_t<std::is_integral_v<T>, T, uint64_t>;
      auto seq_fun= []<sequence_type... Is>(
        T const init, T const sw, std::integer_sequence<sequence_type, Is...>        
      ) {
        return tvl::set<Vec>(
          ((((T)(sizeof...(Is) - 1 - Is))*sw)+init)...
        );
      };
      return seq_fun(start, stepwidth, std::make_integer_sequence<sequence_type, Vec::vector_element_count()>());
  #SCALAR
  - target_extension: "scalar"
    ctype: [ "uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double" ]
    lscpu_flags: []
    implementation: "return start;"
...
---
primitive_name: "gather"
brief_description: "Transfers data from arbitrary locations into a vector register."
additional_non_specialized_template_parameters:
  - ctype: "int"
    name: "N"
parameters:
  - ctype: "const void *"
    name: "memory"
    description: "(Start)pointer of the memory (which is used as base for address calculation)."
  - ctype: "const typename Vec::offset_base_register_type"
    name: "index"
    description: "Offsets array containing simd<offset_t, EXTENSION> register_types containing relative offsets to the start pointer (the number of array elements depend on the sizeof(offset_type)/sizeof(base_type) ratio, where sizeof(offset_type) should be 8)."
  - ctype: "std::integral_constant<int, N>"
    name: "scale"
    description: "Scale."
    declaration_attributes: "[[maybe_unused]]"
returns:
  ctype: "typename Vec::register_type"
  description: "Vector containing gathered data."
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint32_t", "uint64_t", "int32_t", "int64_t"]
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_i{{ intrin_tp[ctype][1] }}gather_epi{{ intrin_tp[ctype][1] }}(index, memory, scale());"
  - target_extension: "avx512"
    ctype: ["float"]
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_i32gather_ps(index, memory, scale());"
  - target_extension: "avx512"
    ctype: ["double"]
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_i64gather_pd(index, memory, scale());"
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint64_t", "int64_t"]
    lscpu_flags: ["avx2"]
    implementation: "return _mm256_i64gather_epi64(reinterpret_cast<long long int const *>(memory), index, scale());"
  - target_extension: "avx2"
    ctype: ["uint32_t", "int32_t"]
    lscpu_flags: ["avx2"]
    implementation: "return _mm256_i32gather_epi32(reinterpret_cast<int const *>(memory), index, scale());"
  - target_extension: "avx2"
    ctype: ["float"]
    lscpu_flags: ["avx2"]
    implementation: "return _mm256_i32gather_ps(reinterpret_cast<float const *>(memory), index, scale());"
  - target_extension: "avx2"
    ctype: ["double"]
    lscpu_flags: ["avx2"]
    implementation: "return _mm256_i64gather_pd(reinterpret_cast<double const *>(memory), index, scale());"
  #INTEL - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: ['sse2']
    is_native: False
    implementation: |
      alignas(Vec::vector_size_B()) std::array<typename Vec::base_type, Vec::vector_element_count()> result{};
      using offsetExt = typename Vec::transform_extension<Vec::offset_base_type>;
      auto const idx_array = tvl::to_array<offsetExt>(index);
      if constexpr(N == 1) {
        auto mem = reinterpret_cast<char const*>(memory);
        for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
          result[i] = mem[idx_array[i]];      
        }
      } else {
        if constexpr(N == sizeof(typename Vec::base_type)) {
          auto mem = reinterpret_cast<typename Vec::base_type const *>(memory);
          for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
            result[i] = mem[idx_array[i]];      
          }
        } else {
          auto mem = reinterpret_cast<char const*>(memory);
          for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
            result[i] = mem[idx_array[i]*scale()];      
          }
        }
      }
      return tvl::load<Vec>(result.data());
  #ARM - NEON
  - target_extension: "neon"
    ctype: "int64_t"
    lscpu_flags: [ 'neon' ]
    is_native: False
    implementation: >
      auto mem = reinterpret_cast<typename Vec::base_type const *>(memory);
      auto tmp = vdupq_n_s64( ( mask[ 0 ] == 0 ) ? source[ 0 ] : mem[ index[ 0 ][ 0 ] ] );
      return vsetq_lane_s64( ( ( mask[ 1 ] == 0 ) ? source[ 1 ] : mem[ index[ 0 ][ 1 ] ] ), tmp, 1 );
  #SCALAR
  - target_extension: "scalar"
    ctype: [ "uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double" ]
    lscpu_flags: [ ]
    implementation: "return reinterpret_cast<typename Vec::base_type const *>(memory)[index];"
...
---
primitive_name: "gather"
functor_name: "mask_gather"
brief_description: "Transfers data from arbitrary locations into a vector register."
additional_non_specialized_template_parameters:
  - ctype: "int"
    name: "N"
parameters:
  - ctype: "const typename Vec::mask_type"
    name: "mask"
    description: "Mask indicating which lanes should be gathered."
  - ctype: "const typename Vec::register_type"
    name: "source"
    description: "Vector register containing values which should be preserved depending on the mask (if mask[i] == 0)."
  - ctype: "const void *"
    name: "memory"
    description: "(Start)pointer of the memory (which is used as base for address calculation)."
  - ctype: "const typename Vec::offset_base_register_type"
    name: "index"
    description: "Offsets array containing simd<offset_t, EXTENSION> register_types containing relative offsets to the start pointer (the number of array elements depend on the sizeof(offset_type)/sizeof(base_type) ratio, where sizeof(offset_type) should be 8)."
  - ctype: "std::integral_constant<int, N>"
    name: "scale"
    description: "Scale."
    declaration_attributes: "[[maybe_unused]]"
returns:
  ctype: "typename Vec::register_type"
  description: "Vector containing gathered data."
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint32_t", "uint64_t", "int32_t", "int64_t"]
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_mask_i{{ intrin_tp[ctype][1] }}gather_epi{{ intrin_tp[ctype][1] }}(source, mask, index, memory, scale());"
  - target_extension: "avx512"
    ctype: ["float"]
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_mask_i32gather_ps(source, mask, index, memory, scale());"
  - target_extension: "avx512"
    ctype: ["double"]
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_mask_i64gather_pd(source, mask, index, memory, scale());"
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint64_t", "int64_t"]
    lscpu_flags: ["avx2"]
    implementation: "return _mm256_mask_i64gather_epi64(source, reinterpret_cast<long long int const *>(memory), index, mask, scale());"
  - target_extension: "avx2"
    ctype: ["uint32_t", "int32_t"]
    lscpu_flags: ["avx2"]
    implementation: "return _mm256_mask_i32gather_epi32(source, reinterpret_cast<int const *>(memory), index, mask, scale());"
  - target_extension: "avx2"
    ctype: ["float"]
    lscpu_flags: ["avx2"]
    implementation: "return _mm256_mask_i32gather_ps(source, reinterpret_cast<float const *>(memory), index, mask, scale());"
  - target_extension: "avx2"
    ctype: ["double"]
    lscpu_flags: ["avx2"]
    implementation: "return _mm256_mask_i64gather_pd(source, reinterpret_cast<double const *>(memory), index, mask, scale());"
  #INTEL - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: [ 'sse2' ]
    is_native: False
    implementation: |
      alignas(Vec::vector_size_B()) std::array<typename Vec::base_type, Vec::vector_element_count()> result{};
      using offsetExt = typename Vec::transform_extension<Vec::offset_base_type>;
      auto const idx_array = tvl::to_array<offsetExt>(index);
      auto const src_array = tvl::to_array<Vec>(source);
      auto const mask_array = tvl::to_array<Vec>(mask);
      if constexpr(N == 1) {
        auto mem = reinterpret_cast<char const*>(memory);
        for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
          result[i] = (mask_array[i] == 0) ? src_array[i] : mem[idx_array[i]];      
        }
      } else {
        if constexpr(N == sizeof(typename Vec::base_type)) {
          auto mem = reinterpret_cast<typename Vec::base_type const *>(memory);
          for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
            result[i] = (mask_array[i] == 0) ? src_array[i] : mem[idx_array[i]];      
          }
        } else {
          auto mem = reinterpret_cast<char const*>(memory);
          for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
            result[i] = (mask_array[i] == 0) ? src_array[i] : mem[idx_array[i]*scale()];      
          }
        }
      }
      return tvl::load<Vec>(result.data());
  #ARM - NEON
  - target_extension: "neon"
    ctype: "int64_t"
    lscpu_flags: [ 'neon' ]
    is_native: False
    implementation: |
      auto mem = reinterpret_cast<typename Vec::base_type const *>(memory);
      auto tmp = vdupq_n_s64( ( mask[ 0 ] == 0 ) ? source[ 0 ] : mem[ index[ 0 ][ 0 ] ] );
      return vsetq_lane_s64( ( ( mask[ 1 ] == 0 ) ? source[ 1 ] : mem[ index[ 0 ][ 1 ] ] ), tmp, 1 );
  #SCALAR
  - target_extension: "scalar"
    ctype: [ "uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double" ]
    lscpu_flags: [ ]
    implementation: "return (mask&1)==1 ? reinterpret_cast<typename Vec::base_type const *>(memory)[index] : source;"
...
---
primitive_name: "scatter"
brief_description: "Transfers data from a vector register to an arbitrary locations."
additional_non_specialized_template_parameters:
  - ctype: "int"
    name: "N"
parameters:
  - ctype: "const typename Vec::register_type"
    name: "data"
    description: "Vector register containing values which should be scattered to memory."
  - ctype: "void *"
    name: "memory"
    description: "(Start)pointer of the memory (which is used as base for address calculation)."
  - ctype: "const typename Vec::offset_base_register_type"
    name: "index"
    description: "Offsets array containing simd<offset_t, EXTENSION> register_types containing relative offsets to the start pointer (the number of array elements depend on the sizeof(offset_type)/sizeof(base_type) ratio, where sizeof(offset_type) should be 8)."
  - ctype: "std::integral_constant<int, N>"
    name: "scale"
    description: "Scale."
    declaration_attributes: "[[maybe_unused]]"
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ["avx512f"]
    implementation: |
      _mm512_i{{ intrin_tp[ctype][1] }}scatter_epi{{ intrin_tp[ctype][1] }}(
         memory, index, data, scale()
      );
  - target_extension: "avx512"
    ctype: ["float"]
    lscpu_flags: ["avx512f"]
    implementation: "_mm512_i32scatter_ps(memory, index, data, scale());"
  - target_extension: "avx512"
    ctype: ["double"]
    lscpu_flags: ["avx512f"]
    implementation: "_mm512_i64scatter_pd(memory, index, data, scale());"
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["avx2"]
    is_native: False
    includes: ["<array>"]
    implementation: |
      auto const val_array = tvl::to_array<Vec>(data);
      using offsetExt = typename Vec::transform_extension<Vec::offset_base_type>;
      auto const idx_array = tvl::to_array<offsetExt>(index);
      #pragma unroll
      for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
        if constexpr(N==sizeof(typename Vec::base_type)) {
          auto mem = reinterpret_cast<typename Vec::base_type *>(memory); 
          mem[idx_array[i]] = val_array[i];
        } else {
          if constexpr(N==1) {
            *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[idx_array[i]]) = val_array[i];
          } else {
            *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[(idx_array[i]<<(cilog2(N)))]) = val_array[i];
          }
        }
      }
  #INTEL - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: [ 'sse2' ]
    includes: ["<array>"]
    is_native: False
    implementation: |
      auto const val_array = tvl::to_array<Vec>(data);
      using offsetExt = typename Vec::transform_extension<Vec::offset_base_type>;
      auto const idx_array = tvl::to_array<offsetExt>(index);
      #pragma unroll
      for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
        if constexpr(N==sizeof(typename Vec::base_type)) {
          auto mem = reinterpret_cast<typename Vec::base_type *>(memory);
          mem[idx_array[i]] = val_array[i];
        } else {
          if constexpr(N==1) {
            *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[idx_array[i]]) = val_array[i];
          } else {
            *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[(idx_array[i]<<(cilog2(N)))]) = val_array[i];
          }
        }
      }
  #ARM - NEON
  - target_extension: "neon"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: [ 'neon' ]
    includes: ["<array>"]
    is_native: False
    implementation: |
      auto const val_array = tvl::to_array<Vec>(data);
      using offsetExt = typename Vec::transform_extension<Vec::offset_base_type>;
      auto const idx_array = tvl::to_array<offsetExt>(index);
      #pragma unroll
      for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
        if(mask_array[i] != 0) {
        if constexpr(N==sizeof(typename Vec::base_type)) {
          auto mem = reinterpret_cast<typename Vec::base_type *>(memory);
          mem[idx_array[i]] = val_array[i];
        } else {
          if constexpr(N==1) {
            *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[idx_array[i]]) = val_array[i];
          } else {
            *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[(idx_array[i]<<(cilog2(N)))]) = val_array[i];
          }
        }
      }
  #SCALAR
  - target_extension: "scalar"
    ctype: [ "uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double" ]
    lscpu_flags: [ ]
    implementation: |
      if constexpr(N==sizeof(typename Vec::base_type)) {
        auto mem = reinterpret_cast<typename Vec::base_type *>(memory);
        mem[index] = data;
      } else {
        if constexpr(N==1) {
          *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[index]) = data;
        } else {
          *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[(index<<(cilog2(N)))]) = data;
        }
      }
...
---
primitive_name: "scatter"
functor_name: "mask_scatter"
brief_description: "Transfers data from a vector register to an arbitrary locations."
additional_non_specialized_template_parameters:
  - ctype: "int"
    name: "N"
parameters:
  - ctype: "const typename Vec::mask_type"
    name: "mask"
    description: "Mask indicating which lanes should be scattered."
  - ctype: "const typename Vec::register_type"
    name: "data"
    description: "Vector register containing values which should be scattered to memory."
  - ctype: "void *"
    name: "memory"
    description: "(Start)pointer of the memory (which is used as base for address calculation)."
  - ctype: "const typename Vec::offset_base_register_type"
    name: "index"
    description: "Offsets array containing simd<offset_t, EXTENSION> register_types containing relative offsets to the start pointer (the number of array elements depend on the sizeof(offset_type)/sizeof(base_type) ratio, where sizeof(offset_type) should be 8)."
  - ctype: "std::integral_constant<int, N>"
    name: "scale"
    description: "Scale."
    declaration_attributes: "[[maybe_unused]]"
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ["avx512f"]
    implementation: |
      _mm512_mask_i{{ intrin_tp[ctype][1] }}scatter_epi{{ intrin_tp[ctype][1] }}(
         memory, mask, index, data, scale()
      );
  - target_extension: "avx512"
    ctype: ["float"]
    lscpu_flags: ["avx512f"]
    implementation: "_mm512_mask_i32scatter_ps(memory, mask, index, data, scale());"
  - target_extension: "avx512"
    ctype: ["double"]
    lscpu_flags: ["avx512f"]
    implementation: "_mm512_mask_i64scatter_pd(memory, mask, index, data, scale());"
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["avx2"]
    is_native: False
    includes: ["<array>"]
    implementation: |
      auto const val_array = tvl::to_array<Vec>(data);
      using offsetExt = typename Vec::transform_extension<Vec::offset_base_type>;
      auto const idx_array = tvl::to_array<offsetExt>(index);
      auto const mask_array = tvl::to_array<Vec>(mask);
      #pragma unroll
      for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
        if(mask_array[i] != 0) {
          if constexpr(N==sizeof(typename Vec::base_type)) {
            auto mem = reinterpret_cast<typename Vec::base_type *>(memory);
            mem[idx_array[i]] = val_array[i];
          } else {
            if constexpr(N==1) {
              *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[idx_array[i]]) = val_array[i];
            } else {
              *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[(idx_array[i]<<(cilog2(N)))]) = val_array[i];
            }
          }
        }        
      }
  #INTEL - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: [ 'sse2' ]
    includes: ["<array>"]
    is_native: False
    implementation: |
      auto const val_array = tvl::to_array<Vec>(data);
      using offsetExt = typename Vec::transform_extension<Vec::offset_base_type>;
      auto const idx_array = tvl::to_array<offsetExt>(index);
      auto const mask_array = tvl::to_array<Vec>(mask);
      #pragma unroll
      for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
        if(mask_array[i] != 0) {
          if constexpr(N==sizeof(typename Vec::base_type)) {
            auto mem = reinterpret_cast<typename Vec::base_type *>(memory);
            mem[idx_array[i]] = val_array[i];
          } else {
            if constexpr(N==1) {
              *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[idx_array[i]]) = val_array[i];
            } else {
              *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[(idx_array[i]<<(cilog2(N)))]) = val_array[i];
            }
          }
        }        
      }
  #ARM - NEON
  - target_extension: "neon"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: [ 'neon' ]
    includes: ["<array>"]
    is_native: False
    implementation: |
      alignas(Vec::vector_size_B()) std::array<typename Vec::offset_base_type, Vec::vector_element_count()> idx_array{};
      alignas(Vec::vector_size_B()) std::array<typename Vec::base_type, Vec::vector_element_count()> val_array{};
      alignas(Vec::vector_size_B()) std::array<typename Vec::base_type, Vec::vector_element_count()> mask_array{};
      tvl::store<Vec>(val_array.data(), data);
      tvl::store<typename Vec::transform_extension<Vec::offset_base_type>>(idx_array.data(), index);
      tvl::store<Vec>(mask_array.data(), mask);
      #pragma unroll
      for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
        if(mask_array[i] != 0) {
          if constexpr(N==sizeof(typename Vec::base_type)) {
            auto mem = reinterpret_cast<typename Vec::base_type *>(memory);
            mem[idx_array[i]] = val_array[i];
          } else {
            if constexpr(N==1) {
              *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[idx_array[i]]) = val_array[i];
            } else {
              *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[(idx_array[i]<<(cilog2(N)))]) = val_array[i];
            }
          }
        }        
      }
  #SCALAR
  - target_extension: "scalar"
    ctype: [ "uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double" ]
    lscpu_flags: [ ]
    implementation: |
      if((mask&0b1) != 0) {
        if constexpr(N==sizeof(typename Vec::base_type)) {
          auto mem = reinterpret_cast<typename Vec::base_type *>(memory);
          mem[index] = data;
        } else {
          if constexpr(N==1) {
            *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[index]) = data;
          } else {
            *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[(index<<(cilog2(N)))]) = data;
          }
        }
      }
...
---
primitive_name: "compress_store"
brief_description: "Stores elements from data consecutively, if the corresponding bit in mask is set to 1."
parameters:
  - ctype: "const typename Vec::imask_type"
    name: "mask"
    description: "Mask"
  - ctype: "typename Vec::base_type *"
    name: "memory"
    description: "Memory"
  - ctype: "const typename Vec::register_type"
    name: "data"
    description: "Data"
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: [ "uint32_t", "int32_t", "uint64_t", "int64_t" ]
    lscpu_flags: [ "avx512f" ]
    implementation: "_mm512_mask_compressstoreu_epi{{ intrin_tp[ctype][1] }}(reinterpret_cast<void*>(memory), mask, data);"
  - target_extension: "avx512"
    ctype: ["float", "double"]
    lscpu_flags: [ "avx512f" ]
    implementation: "_mm512_mask_compressstoreu_{{ intrin_tp_full[ctype] }}(reinterpret_cast<void*>(memory), mask, data);"
  - target_extension: "avx512"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t"]
    lscpu_flags: ["avx512f", "avx512vbmi2"]
    implementation: "_mm512_mask_compressstoreu_{{ intrin_tp[ctype][1] }}(reinterpret_cast<void*>(memory), mask, data);"
  - target_extension: "avx512"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t"]
    lscpu_flags: ["avx512f"]
    includes: ["<cstring>"]
    is_native: False
    implementation: |
      auto const orig_mem = memory;
      auto const data_array = tvl::to_array<Vec>(data);
      typename Vec::base_type safe[Vec::vector_element_count()];
      std::memcpy(reinterpret_cast<void*>(safe), reinterpret_cast<void const *>(memory), Vec::vector_size_B());
      #pragma unroll
      for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
        *memory = data_array[i];
        memory += (mask>>i)&0b1;
      }
      if(((mask>>Vec::vector_element_count())&0b1) == 0) {
        *memory = safe[memory-orig_mem];
      }
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["avx2"]
    includes: ["<cstring>"]
    is_native: False
    implementation: |
      auto const orig_mem = memory;
      auto const data_array = tvl::to_array<Vec>(data);
      typename Vec::base_type safe[Vec::vector_element_count()];
      std::memcpy(reinterpret_cast<void*>(safe), reinterpret_cast<void const *>(memory), Vec::vector_size_B());
      #pragma unroll
      for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
        *memory = data_array[i];
        memory += (mask>>i)&0b1;
      }
      if(((mask>>Vec::vector_element_count())&0b1) == 0) {
        *memory = safe[memory-orig_mem];
      }
  - target_extension: "avx2"
    ctype: ["uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ["avx2", "avx512f", "avx512vl"]
    implementation: "_mm256_mask_compressstoreu_epi{{ intrin_tp[ctype][1] }}(reinterpret_cast<void*>(memory), mask, data);"
  - target_extension: "avx2"
    ctype: ["float", "double"]
    lscpu_flags: ["avx2", "avx512f", "avx512vl"]
    implementation: "_mm256_mask_compressstoreu_{{ intrin_tp_full[ctype] }}(reinterpret_cast<void*>(memory), mask, data);"
  - target_extension: "avx2"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t"]
    lscpu_flags: ["avx2", "avx512f", "avx512vbmi2", "avx512vl"]
    implementation: "_mm256_mask_compressstoreu_epi{{ intrin_tp[ctype][1] }}(reinterpret_cast<void*>(memory), mask, data);"
...
---
primitive_name: "expand_load"
brief_description: "Loads contiguos data from a specified memory location and puts the elements using write mask."
parameters:
  - ctype: "const typename Vec::imask_type"
    name: "mask"
    description: "Mask"
  - ctype: "const typename Vec::register_type"
    name: "src"
    description: "Source register. Data is kept if corresponding mask bit is set to 0."
  - ctype: "typename Vec::base_type *"
    name: "memory"
    description: "Memory"
returns:
  ctype: "typename Vec::register_type"
  description: "Vector containing the elements."
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: [ "uint32_t", "int32_t", "uint64_t", "int64_t" ]
    lscpu_flags: [ "avx512f" ]
    implementation: "return _mm512_mask_expandloadu_epi{{ intrin_tp[ctype][1] }}(src, mask, reinterpret_cast<void*>(memory));"
  - target_extension: "avx512"
    ctype: ["float", "double"]
    lscpu_flags: [ "avx512f" ]
    implementation: "return _mm512_mask_expandloadu_{{ intrin_tp_full[ctype] }}(src, mask, reinterpret_cast<void*>(memory));"
  - target_extension: "avx512"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t"]
    lscpu_flags: ["avx512f", "avx512vbmi2"]
    implementation: "return _mm512_mask_expandloadu_epi{{ intrin_tp[ctype][1] }}(src, mask, reinterpret_cast<void*>(memory));"
  - target_extension: "avx512"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t"]
    lscpu_flags: ["avx512f"]
    includes: ["<cstring>"]
    is_native: False
    implementation: |
      //@todo: optimizable
      alignas(Vec::vector_alignment()) std::array<typename Vec::base_type, Vec::vector_element_count()> data_array;
      auto src_array = tvl::to_array<Vec>(src);
      auto mem = memory;
      for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
        if(((mask>>i)&0b1)==0) {
          data_array[i] = src_array[i];
        } else {
          data_array[i] = *mem;
          ++mem;
        }
      }
      return _mm512_load_si512(reinterpret_cast<void const *>(data_array.data()));
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["avx2"]
    includes: ["<cstring>"]
    is_native: False
    implementation: |
      //@todo: optimizable
      alignas(Vec::vector_alignment()) std::array<typename Vec::base_type, Vec::vector_element_count()> data_array;
      auto src_array = tvl::to_array<Vec>(src);
      auto mem = memory;
      for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
        if(((mask>>i)&0b1)==0) {
          data_array[i] = src_array[i];
        } else {
          data_array[i] = *mem;
          ++mem;
        }
      }
      return tvl::load<Vec>(data_array.data());
      //return _mm256_load_si256(reinterpret_cast<__m256i const *>(data_array.data()));
  - target_extension: "avx2"
    ctype: ["uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ["avx2", "avx512f", "avx512vl"]
    implementation: "return _mm256_mask_expandloadu_epi{{ intrin_tp[ctype][1] }}(src, mask, reinterpret_cast<void const*>(memory));"
  - target_extension: "avx2"
    ctype: ["float", "double"]
    lscpu_flags: ["avx2", "avx512f", "avx512vl"]
    implementation: "return _mm256_mask_expandloadu_{{ intrin_tp_full[ctype] }}(src, mask, reinterpret_cast<void const *>(memory));"
  - target_extension: "avx2"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t"]
    lscpu_flags: ["avx2", "avx512f", "avx512vbmi2", "avx512vl"]
    implementation: "return _mm256_mask_expandloadu_epi{{ intrin_tp[ctype][1] }}(src, mask, reinterpret_cast<void const*>(memory));"
...
---
primitive_name: "load_convert_up"
additional_simd_template_parameter: "ToType"
parameters:
  - ctype: "typename Vec::base_type const *"
    name: "memory"
    description: "Memory"
returns:
  ctype: "typename ToType::register_type"
  description: "Vector containing the data."
definitions:
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: [ "uint8_t", "uint16_t", "uint32_t" ]
    additional_simd_template_base_type_mapping_dict: { "uint8_t": ["uint16_t", "uint32_t", "uint64_t", "int16_t", "int32_t", "int64_t"], "uint16_t": ["uint32_t", "uint64_t", "int32_t", "int64_t"], "uint32_t": ["uint64_t", "int64_t"]}
    lscpu_flags: ["sse2", "avx2"]
    is_native: False
    implementation: |
      return
        _mm256_and_si256(
          tvl::set1<ToType>(
            (typename Vec::base_type)~0
          ),
          _mm256_cvtepi{{ intrin_tp[ctype][1] }}_epi{{ intrin_tp[additional_simd_template_base_type][1] }}(
            _mm_loadu_si128(reinterpret_cast<__m128i const *>(memory))
          )
        );
  - target_extension: "avx2"
    ctype: [ "int8_t", "int16_t", "int32_t" ]
    additional_simd_template_base_type_mapping_dict: { "int8_t": ["int16_t", "int32_t", "int64_t"], "int16_t": ["int32_t", "int64_t"], "int32_t": ["int64_t"]}
    lscpu_flags: ["avx2"]
    is_native: False
    implementation: |
      return 
        _mm256_cvtepi{{ intrin_tp[ctype][1] }}_epi{{ intrin_tp[additional_simd_template_base_type][1] }}(
          _mm_loadu_si128(reinterpret_cast<__m128i const *>(memory))
        );
...
